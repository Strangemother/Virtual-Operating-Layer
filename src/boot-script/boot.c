// crt_popen.c
/* This program uses _popen and _pclose to receive a
 * stream of text from a system process.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#define BUFSIZE 128

int main(int argc, char* argv[])
{
    int counter;
    char *path = "\"bios_runtime/vol_runtime.exe\"";
    char *startup_script = "bios_runtime/startup";
    /**
     *  -u     : force the binary I/O layers of stdout and stderr to be unbuffered;
                 stdin is always buffered; text I/O layer will be line-buffered
        -O     : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x
        -OO    : remove doc-strings in addition to the -O optimizations
        -q     : don't print version and copyright messages on interactive startup
        -s     : don't add user site directory to sys.path; also PYTHONNOUSERSITE
        -S     : don't imply 'import site' on initialization
        -q     : don't print version and copyright messages on interactive startup
     */
    char *switches = "-qSsuOO";
    char *cmd = "cmd /V /C \"set PYTHONSTARTUP=%s&& %s %s\"";
    char buffer[strlen(cmd)];
    char psBuffer[BUFSIZE];
    FILE *pPipe;

    printf("Starting VOL Boot through %s\n", argv[0]);

    // if(argc==1)
    //     printf("\nNo Extra Command Line Argument Passed Other Than Program Name");

    // if(argc>=2)
    // {
    //     printf("\nNumber Of Arguments Passed: %d",argc);
    //     printf("\nArgs:");
    //     for(counter=1;counter<argc;counter++){
    //         printf("\nargv[%d]: %s",counter,argv[counter]);
    //         //strcat(switches, argv[counter]);
    //         //snprintf(switches, sizeof switches, "%s", argv[counter]);
    //     }
    // }

    sprintf(buffer, cmd, startup_script, path, switches);
    //printf("(%s)\n", buffer);
    /* Run DIR so that it writes its output to a pipe. Open this
     * pipe with read text attribute so that we can read it
     * like a text file.
     */

   // Relative to the build content
   if( (pPipe = _popen(buffer, "rt" )) == NULL ){
      exit( 1 );
   }

   /* Read pipe until end of file, or an error occurs. */

   while(fgets(psBuffer, BUFSIZE, pPipe)){
      printf(psBuffer);
   }

   /* Close pipe and print return value of pPipe. */
   if( feof( pPipe) ) {
     printf( "Process returned %d\n", _pclose( pPipe ) );
   } else {
     printf( "Error: Failed to read the pipe to the end.\n");
   }
}
