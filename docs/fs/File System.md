# Files

To clarify the reference a 'file', files, folders or the current analogy of assigning
bytes to an address isn't the same within a VOL. Topologically a VOL aggregate will perform the same routine.


# An Aggregate

A single readable unit given by the core _filesystem_ is a reference list of addressable segment 'blocks' distributed as chunks of byte or binary data, to be read by the requesting interface as discreet blocks to either digest individually or _stream_ directly from the VOL API as a linear stream of content.


## Overview

When a user initiates an 'app' to read content - such as a text editor - the tool accesses an Aggregate Pointer _file_ by a given label "foo.one.two".

VOL FS will use the label as a _filename_ to access the permissions header and find the aggregate pointer segment list. The list maintains a set of address to segments. Each address is a standard string used as a VOL FS segment pointer.
The pointer will resolve the segment of data through the HOST or from a remote session.

The returned given to the FS is handled accordingly - converting it to a readable stream for the digesting 'app'. The FS will handle decryption and transportation accordingly (for VOL FS session distributed content).


## Naming

The new patterns and protocols for the VOL FS reside within the concept of natural rock and earth. The field of Pedology defines an Aggregate as a mass of mineraloid particles or rock particles. The whole analogy provides a firm similarity of how VOL will work with a resulting unit.

The end-user exists within an session ecosystem bound upon on layer of smaller segments of usable units. As each unit needs other aspects of a VOL, its particulate structure wouldn't work without a union of homogeneous parts.

A file (Aggregate) in VOL needs its distributed reference pointer (particles) of byte information (segment) of many types, bound together by a header - formed naturally through VOL core-routines and HOST byte data or artificially from remote address segments.


### Overview.

+ Aggregate: ag
+ Header Reference: hr
+ particle Pointer: PP

An ag is the smallest unit of reference the average session user would want to use (consider a 'text' file).
The ag is a list of PP's to segments of real data. Each PP is resolved by the FS and given to the calling 'app' as an ordered data stream.

Written to the VOL core DB the VOL FS maintains a hr of the ag containing a local label reference, create date - and any other meta data you'd generally keep about a file.

To resolve our example text (assume bytes) A combination of a HR > AG > [PP] > [Data]

    > open foo.bar.one
        FS read ag hr: [s4,s2,s1,s3,s5,s345]
        resolve ordered local
        s4,s2
        s1
        start FS return stream
            pre-read step pointer: s2
        < s1: ABCDEFGH...
            pre-read step-pointer: s3
        < s2: ... XYZ0123 ...
            pre-read ...
        < s3: ... 89@...
        ... until resolved.


Essentially a VOL file is a list of other files returned in order to the requesting interface.

When aggregate is mixed together with dry cement and water, the mixture forms a fluid slurry that is easily poured and molded into shape.
The cement reacts chemically with the water and other ingredients to form a hard matrix that binds the materials together into a durable stone-like material that has many uses.


### Phenocryst (Header)

An individual reference unit maintained by the VOL independent of the aggregate or its particles. Known as a Phenocryst it provides meta data and pointing references to the aggregate


### Aggregate (File)

An ag generated by the system for VOL usage is a 'ped'. An ag generated through user activity is known as a 'clod'. Many peds and clods form a 'mass' of particles resolved through their grains.

+ Referenced by a VOL FS Read of the Phenocryst
+ Contains any Particle Pointer / Grain assets (such as certificates)
+ Contains a list of grains
+ May contain Particles

An particle address and its resolution assets in an Aggregate is known as a Grain.
The Grain is implemented by the FS to produce a resolved particle.


### Grain (Particle Pointer)

A grain will manifest as an address-like pointer with some exposure to mounting. The content for a grain should resolve a particle - passing back to the Phenocryst reader or some session api.

When executing a grain is will resolve the content to the local session space with the relative assets and permissions. If a component is missing (such as bad permissions) the grain will not build and the particle will not resolve. Other authorised grains will yield a particle however the local colloid will fail.

Grains will refer to any applicable FS such as HOST, FTP or the custom Graph. Any grains with remote dependencies will quietly compute until a yield.


### Particle (Segment)

A single particle is a unchanging unit of bytes or binary content for digestion with a parent ag. A single particle alone may be useless without its siblings as it will contain a partial subset of of the total aggregate. However a Segment may have a back and forwarding pointer set, allowing an orphaned particle to be rebuilt if the header is lost.

A subset of particles is Known as a Colloid. During processing VOL FS will maintain a colloid of the aggregate.


#### Solid Particles

A Particle defines a chunk of content in the FS. It may be persistently stored anywhere or exist as immediate user environment information. If the Particle content is _baked_ into a service location - such as written as bytes to a HDD - it's referred to as a 'solid' particle, as it will not change over time. The antithesis of this is not known yet _A liquid particle?_. But a set of phases exist for a Particle

+ Solid: Unchanging stored content, or hardcoded into the Particle exposed api.
+ fluid: The Particle exists as a Phenocryst reference but the content is volatile - RAM cached likely
+ floating: The particle reference and its content isn't applied to a graph. It's orphaned without an owner or a reference graph. If a particle was of a group (constituting a grain) its content may not be complete, yielding a 'sedimented particle'.


### Colloid

A Colloid (as a function) represents a 'read' like function to collect and resolve particles through an association of names or space.

A Colloid refers to one or more particles. When Applying a colloid, you create one or more particles associated by a grain. The colloid will fetch the particles under the grain. When using _fetching_ through a colloid, you may not return an entire grain; as a grain may contain colloids and particles (also grains) with other identities.

When fetching a colloid you may be returning a list of particles, or grains


#### Coalesce Colloids (merging)

A colloid consists of many Particles suspended in a phase of potentially volatile or dispersed grains.
Because the size of the dispersed phase may be difficult to measure, and because colloids have the appearance of grains, colloids are sometimes identified and characterized by their transport properties. For example, if a colloid consists of a solid phase dispersed in a user space, the solid particles will not diffuse through a membrane\*.


# Membrane

Although not spoken about in the FS documentation. The Membrane is the network and connective layer originating from a host vol. It binds the FS and user space, with the network space.

---

When agglomerating particle content the information is naturally stored through the default FS on the host system. this content is smartly managed by the FS 'kernel?' to disseminate to the appropriate tooling. A particle is stored in a location governed by the gain and its reference header.

The reference header is kept on the _local_ system acting as a standard filesystem registry. All files have an entry, addressable by their reference. A Particle reference name is arbitrary. Many items may have the same particle reference yielding a grain to complete an aggregate.


# Storing.

When storing information, the system will apply a reference to a particle and store this in the best location as determined by the Phenocryst (an addressable grain referring to a header in the local cache) and space setting.

When creating an entity for the base fs, you'll apply a particle or many particles as a grain. Initially the entry point is a `colloid` to be stored against a reference. The system will apply the particle content in the correct location.


# Fetching

Calling to the FS yields particles, potentially as a grain. A particle name is not unique but may be used uniquely. Therefore a request for content may return 1 or more particles to coalesce. Performing a FS call may occur low-level, targeting a designated service or local space. If the same is done across the membrane, the request is distributed to all VOL clients.

The Host maintains ownership of the request and transport and the calling unit accepts many distributed particle references (in the form of a colloid), to resolve as an ordered sequence for user iteration. This calls upon the distributed by design architecture applied to the VOL kernel.
