# Zero Suite (first run)

The first services to execute after a MBR handoff.

+ Code libs and VM
+ Pointer class
+ Memory Allocations
+ Executor placements

---

The base system requires:

+ VM (source machine)
+ Memory

Once the VM is loaded with possible functions, the first functions will load the contigious memory spaces. A "pointer" is the defacto unit of motion and execution of source, as such the _pointer_ is a VM fundamental.

The pointers first job will be _allocate memory_ and the zero suite state.

---

pointer 0 is an executable (.bin or .elf like structure) to initiate the core code, this is essentially unpacked and loaded into the primary allowed memory. The pointer zero payload has all the assets for an effective VM, for the Pointer to _step into_ position 0 - of which is the _default_.

From there the magic value sends the pointer to the first postion.

---

During this state there is no graph, pointer stepper (or machine). Generally no _os_ of any form. Think of this as a pointer sitting alone in a void of no tasks or connections.


# Pointing the Pointer

The pointer knows very little about the functionality of its position. In it's zero-state form, it has the _source under control_, a position (vector location), and _maybe_ a name.

A Pointer is self-affirming. As the pointer _moves_ to a new position is will naturally actuate its source requirements and the code underneath. The pointer class is a host for injecting features; from the SES code or from external addons (such as core module extensions).

---

Primary

the baked loadout opens an expected file (a compiled exec)
