The root functions and all internal memory assests exist on a graph based memory layout. All data, functional executional steps and register management is handled through a graph of connected key value pairs. Each key address with the monolith data structures returns a value of bytes, or an _executable_ with access to the same monolith.

The data graph applies a chain of bytes, yielding a byte array for system digestion. The function graph steps through executable functions, with side-effects through graph connections.


# Data

The data graph is fairly simple. Every value of found within a graph of keys executes an ordered chain of data. The edge references are stored away from the data references, merged at runtime by the acquisition unit.

# Functions

A functional call assigns the same interactive stepping, with each chain yield resulting in an expected executable. The returned function accepts arguments and executes natural chains through the a similar edge graph.


---

When utilising the terminal input a user will input _commands_ as string bytes references for the key graph; In the _lowest frame `0`_ (The _pre bios_ area), all commands are code references. The basic commands consist of `print`.

---

As everything works upon the graph sequencing, the +1 frame allows throughput of data through graph reference pointers. At this layer we gain _root imports_, the com libraries to graph upon - and VOL root apps (not c compiled builtins.)

